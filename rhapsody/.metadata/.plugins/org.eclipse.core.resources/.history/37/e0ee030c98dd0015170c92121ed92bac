
	/*process*/
	Process Button_ex 
	[]

 
	is
	states 
			Off_Button_ex,
			On_Button_ex
	init
		to Off_Button_ex

	from Off_Button_ex
		Pressed;
          receiveFromButton_Ex ! requestFloor;
          to On_Button_ex

		
	from On_Button_ex
		select
          arrive;
          to Off_Button_ex        
		
		[]
          wait[4,5];
          to Off_Button_ex
          end;
		

	Process ControllerSys 
	[]

 
	is
	states 
			Wait_ControllerSys,
			cabinMoved_ControllerSys,
			cabinArrived_ControllerSys,
			doorOpened_ControllerSys,
			doorClosed_ControllerSys,
			receiveRequestFromButtonEx_ControllerSys,
			cabinBraked_ControllerSys,
			recievedRequestFromCabin_ControllerSys,
			waitDoorClosed_ControllerSys
		var 
			exBtnFloor,
			currentFloor,
			isBusy,
			upordown,
			targetFloor,
			destFloor,
			loadedPassager
	init
		exBtnFloor := -1;
		currentFloor := 0;
		isBusy := false;
		upordown := 0;
		targetFloor := -1;
		destFloor := -1;
		loadedPassager := false;
		to Wait_ControllerSys

	from Wait_ControllerSys
		receiveFromButton_Ex ?  exBtnFloor;
destFloor := exBtnFloor;
if (currentFloor < exBtnFloor) then
          goUp;   
          upordown :=1 ;  
          case (exBtnFloor) of 
               0 ->  sendToMeasureSensor ! currentFloor, exBtnFloor
            | 1 ->  sendToMeasureSensor_1 ! currentFloor, exBtnFloor
            | 2 ->  sendToMeasureSensor_2 ! currentFloor, exBtnFloor
            | 3 ->  sendToMeasureSensor_3 ! currentFloor, exBtnFloor
            | 4 ->  sendToMeasureSensor_4 ! currentFloor, exBtnFloor
                end;
                to ReceiveRequestFromButtonEx_ControllerSys
elseif (currentFloor > exBtnFloor) then 	
	goDown; 
	upordown := -1;  
                case (exBtnFloor) of 
               0 ->  sendToMeasureSensor !  currentFloor,  exBtnFloor
            | 1 ->  sendToMeasureSensor_1 !  currentFloor, exBtnFloor
            | 2 ->  sendToMeasureSensor_2 !  currentFloor, exBtnFloor
            | 3 ->  sendToMeasureSensor_3 !  currentFloor, exBtnFloor
            | 4 ->  sendToMeasureSensor_4 !  currentFloor, exBtnFloor
                end;
               to ReceiveRequestFromButtonEx
else
               to ReceiveRequestFromButtonEx
end


		
	from cabinMoved_ControllerSys
		select
          p_sen_con_detected
[]
          p_sen_con_1_detected 
[]
          p_sen_con_2_detected
[]
          p_sen_con_3_detected 
[]
          p_sen_con_4_detected 
end;
stopFromController;
to cabinArrived_ControllerSys

		
		select
          p_sen_con_continueToMove 
[]
          p_sen_con_1_continueToMove 
[]
          p_sen_con_2_continueToMove 
[]
          p_sen_con_3_continueToMove 
[]
          p_sen_con_4_continueToMove 
end;
currentFloor = currentFloor +upordown;
case (destFloor) of 
               0 ->  toMeasureSensor ! currentFloor, destfloor
            | 1 ->  sendToMeasureSensor_1 ! currentFloor, destfloor
            | 2 ->  sendToMeasureSensor_2 ! currentFloor, destfloor
            | 3 ->  sendToMeasureSensor_3 ! currentFloor, destfloor
            | 4 ->  sendToMeasureSensor_4 ! currentFloor, destfloor
end;

		
	from cabinArrived_ControllerSys
		braked;
stop;
to cabinBraked
		
	from doorOpened_ControllerSys
		targetFloor := 1;
destFloor := targetFloor;
closeDoor;
to doorClosed_ControllerSys
		
		if (loadedPassager) then
          CloseDoor;
          to waitDoorClosed
end
		
	from doorClosed_ControllerSys
		readyToGo;
if (currentFloor < targetFloor) then
	getP_con_win().gen(new goUp());   
	upordown := 1; 
	sendToMeasureSensor(targetFloor);
else
	if (currentFloor == targetFloor) then
                                openDoor;
		to doorOpened_ControllerSys
	else
		getP_con_win().gen(new goDown()); 
		upordown := -1;  
		sendToMeasureSensor(targetFloor);
	end
end; 
to recievedRequestFromCabin_ControllerSys
		
		doneTask
		
	from receiveRequestFromButtonEx_ControllerSys
		receiveCabinMoved;
currentFloor := currentFloor + upordown;
case (exBtnFloor) of 
               0 ->  sendToMeasureSensor ! currentFloor, exBtnFloor
            | 1 ->  sendToMeasureSensor_1 !  currentFloor, exBtnFloor
            | 2 ->  sendToMeasureSensor_2 !  currentFloor, exBtnFloor
            | 3 ->  sendToMeasureSensor_3 !  currentFloor, exBtnFloor
            | 4 ->  sendToMeasureSensor_4 !  currentFloor, exBtnFloor
 end;
to cabinMoved_ControllerSys

		
		if (currentFloor = exBtnFloor) then   
//getP_con_door().gen (new OpenDoor());
                p_con_door_OpenDoor;
	to doorOpened
end;

		
	from cabinBraked_ControllerSys
		readyToOpenDoor;
OpenDoor;
to doorOpened_ControllerSys

		
	from recievedRequestFromCabin_ControllerSys
		receiveCabinMoved    (s: recievedRequestFromCabin, t: cabinMoved)
		
		gotoOpenDoorDirectly    (s: recievedRequestFromCabin, t: cabinBraked )
		
	from waitDoorClosed_ControllerSys
		readyToGo;
loadedPassager := false;
to Wait

		

	Process Winch 
	[]

 
	is
	states 
			Not_Going_Winch,
			Going_Up_Winch,
			Going_Down_Winch,
			receiveCabinBrakedFromControllerSys_Winch
		var 
			motor,
			frein,
			selector
	init
		motor := 0;
		frein := 0;
		selector := 0;
		to Not_Going_Winch

	from Not_Going_Winch
		goUp;
          moveCabinUp;
          to Going_Up
		
		goDown;
          moveCabinDown;
//getP_win_cab().gen(new moveCabinDown());
          to Goinf_Down
		
	from Going_Up_Winch
		stopFromController;
          braked;
          to receiveCabinBrakedFromControllerSys
		
	from Going_Down_Winch
		stopFromController;
//getP_win_cab().gen(new braked());
          p_win_cab_braked;
           to receiveCabinBrakedFromControllerSys
		
	from receiveCabinBrakedFromControllerSys_Winch
		stop;
          readyToOpenDoor;
          to Not_Going_Winch
		

	Process Cabin 
	[]

 
	is
	states 
			Stop_Cabin,
			Down_Cabin,
			sentInfo_Cabin,
			Up_Cabin
		var 
			currentFloor
	init
		currentFloor := 0;
		to Stop_Cabin

	from Stop_Cabin
		sendFloorAndCloseDoor  ?  targetFloor;
receiveFloorAndCloseDoor !  targetFloor;
to sentInfo_Cabin
		
		moveCabinDown;
P_cab_con_braked;
to Down_Cabin
		
		moveCabinUp;
          receiveCabinMoved;
          to Up_Cabin


		
	from Down_Cabin
		braked;
p_cab_con_braked;
to Stop_Cabin
		
	from sentInfo_Cabin
		moveCabinDown ;
p_cab_con_receiveCabinMoved;
		
		moveCabinUp;
p_cab_con_receiveCabinMoved;
to Up_Cabin
		
	from Up_Cabin
		braked;
p_cab_con_braked;
to Stop_Cabin

		

	Process Door 
	[]

 
	is
	states 
			Open_Door,
			Closed_Door,
			Sleep_Door
	init
		to Sleep_Door

	from Open_Door
		CloseDoor;
to Closed_Door
		
	from Closed_Door
		readyToGo;
to Sleep_Door
		
	from Sleep_Door
		OpenDoor;
to Open_Door

		

	Process Sensor 
	[]

 
	is
	states 
			Idle_Sensor,
			Detecting_Sensor,
			Detected_Sensor
		var 
			floor,
			cabinFloor
	init
		floor := -1;
		cabinFloor := -1;
		to Idle_Sensor

	from Idle_Sensor
		toMeasure ?  floor, cabinFloor;
to Detecting_Sensor

		
	from Detecting_Sensor
		case (floor) of 
          0 -> p_sen_con_detected 
       | 1 -> P_sen_con_1_detected
       | 2 -> p_sen_con_2_detected   
       | 3 -> p_sen_con_3_detected 
       | 4 -> p_sen_con_4_detected
end;
to Detected_Sensor
		
		toMeasure ? cabinFloor;
if (floor = cabinFloor) then 
            to Detected_Sensor
else
            case (floor) of 
          0 -> p_sen_con_continueToMove 
       | 1 -> P_sen_con_1_continueToMove
       | 2 -> p_sen_con_2_continueToMove
       | 3 -> p_sen_con_3_continueToMove 
       | 4 -> p_sen_con_4_continueToMove
end;
to Detected_Sensor

		
	from Detected_Sensor
		to Idle_Sensor
		

	Process Sensor 
	[]

 
	is
	states 
			Idle_Sensor,
			Detecting_Sensor,
			Detected_Sensor
		var 
			floor,
			cabinFloor
	init
		floor := -1;
		cabinFloor := -1;
		to Idle_Sensor

	from Idle_Sensor
		toMeasure ?  floor, cabinFloor;
to Detecting_Sensor

		
	from Detecting_Sensor
		case (floor) of 
          0 -> p_sen_con_detected 
       | 1 -> P_sen_con_1_detected
       | 2 -> p_sen_con_2_detected   
       | 3 -> p_sen_con_3_detected 
       | 4 -> p_sen_con_4_detected
end;
to Detected_Sensor
		
		toMeasure ? cabinFloor;
if (floor = cabinFloor) then 
            to Detected_Sensor
else
            case (floor) of 
          0 -> p_sen_con_continueToMove 
       | 1 -> P_sen_con_1_continueToMove
       | 2 -> p_sen_con_2_continueToMove
       | 3 -> p_sen_con_3_continueToMove 
       | 4 -> p_sen_con_4_continueToMove
end;
to Detected_Sensor

		
	from Detected_Sensor
		to Idle_Sensor
		

	Process Sensor 
	[]

 
	is
	states 
			Idle_Sensor,
			Detecting_Sensor,
			Detected_Sensor
		var 
			floor,
			cabinFloor
	init
		floor := -1;
		cabinFloor := -1;
		to Idle_Sensor

	from Idle_Sensor
		toMeasure ?  floor, cabinFloor;
to Detecting_Sensor

		
	from Detecting_Sensor
		case (floor) of 
          0 -> p_sen_con_detected 
       | 1 -> P_sen_con_1_detected
       | 2 -> p_sen_con_2_detected   
       | 3 -> p_sen_con_3_detected 
       | 4 -> p_sen_con_4_detected
end;
to Detected_Sensor
		
		toMeasure ? cabinFloor;
if (floor = cabinFloor) then 
            to Detected_Sensor
else
            case (floor) of 
          0 -> p_sen_con_continueToMove 
       | 1 -> P_sen_con_1_continueToMove
       | 2 -> p_sen_con_2_continueToMove
       | 3 -> p_sen_con_3_continueToMove 
       | 4 -> p_sen_con_4_continueToMove
end;
to Detected_Sensor

		
	from Detected_Sensor
		to Idle_Sensor
		

	Process Sensor 
	[]

 
	is
	states 
			Idle_Sensor,
			Detecting_Sensor,
			Detected_Sensor
		var 
			floor,
			cabinFloor
	init
		floor := -1;
		cabinFloor := -1;
		to Idle_Sensor

	from Idle_Sensor
		toMeasure ?  floor, cabinFloor;
to Detecting_Sensor

		
	from Detecting_Sensor
		case (floor) of 
          0 -> p_sen_con_detected 
       | 1 -> P_sen_con_1_detected
       | 2 -> p_sen_con_2_detected   
       | 3 -> p_sen_con_3_detected 
       | 4 -> p_sen_con_4_detected
end;
to Detected_Sensor
		
		toMeasure ? cabinFloor;
if (floor = cabinFloor) then 
            to Detected_Sensor
else
            case (floor) of 
          0 -> p_sen_con_continueToMove 
       | 1 -> P_sen_con_1_continueToMove
       | 2 -> p_sen_con_2_continueToMove
       | 3 -> p_sen_con_3_continueToMove 
       | 4 -> p_sen_con_4_continueToMove
end;
to Detected_Sensor

		
	from Detected_Sensor
		to Idle_Sensor
		

	Process Sensor 
	[]

 
	is
	states 
			Idle_Sensor,
			Detecting_Sensor,
			Detected_Sensor
		var 
			floor,
			cabinFloor
	init
		floor := -1;
		cabinFloor := -1;
		to Idle_Sensor

	from Idle_Sensor
		toMeasure ?  floor, cabinFloor;
to Detecting_Sensor

		
	from Detecting_Sensor
		case (floor) of 
          0 -> p_sen_con_detected 
       | 1 -> P_sen_con_1_detected
       | 2 -> p_sen_con_2_detected   
       | 3 -> p_sen_con_3_detected 
       | 4 -> p_sen_con_4_detected
end;
to Detected_Sensor
		
		toMeasure ? cabinFloor;
if (floor = cabinFloor) then 
            to Detected_Sensor
else
            case (floor) of 
          0 -> p_sen_con_continueToMove 
       | 1 -> P_sen_con_1_continueToMove
       | 2 -> p_sen_con_2_continueToMove
       | 3 -> p_sen_con_3_continueToMove 
       | 4 -> p_sen_con_4_continueToMove
end;
to Detected_Sensor

		
	from Detected_Sensor
		to Idle_Sensor
		

	/*Component*/
	Component InstanceClsDiag is 
	par
	
	
			Button_ex,
			ControllerSys,
			Winch,
			Cabin,
			Door,
			Sensor,
			Sensor,
			Sensor,
			Sensor,
			Sensor
	

