
/* ============================ declare element type in FIFO =====================================*/
type Button_exEvents is union
		| Pressed
		| arrive
		| tm(5)
end

type ControllerSysEvents is union
		| receiveFromButton_Ex
		| detected
		| continueToMove
		| braked
		| receiveFloorAndCloseDoor
		| readyToOpenDoor
		| doneTask
		| receiveCabinMoved
		| gotoOpenDoorDirectly
		| readyToOpenDoor
		| receiveCabinMoved
		| gotoOpenDoorDirectly
		| readyToGo
end

type WinchEvents is union
		| goUp
		| goDown
		| stopFromController
		| stopFromController
		| stop
end

type CabinEvents is union
		| sendFloorAndCloseDoor
		| moveCabinDown
		| moveCabinUp
		| braked
		| moveCabinDown
		| moveCabinUp
		| braked
end

type DoorEvents is union
		| CloseDoor
		| OpenDoor
end

type SensorEvents is union
		| toMeasure
		| cabinArrived
		| toMeasure
		| tm(1)
end

type SensorEvents is union
		| toMeasure
		| cabinArrived
		| toMeasure
		| tm(1)
end

type SensorEvents is union
		| toMeasure
		| cabinArrived
		| toMeasure
		| tm(1)
end

type SensorEvents is union
		| toMeasure
		| cabinArrived
		| toMeasure
		| tm(1)
end

type SensorEvents is union
		| toMeasure
		| cabinArrived
		| toMeasure
		| tm(1)
end

	/*declare FIFO*/
type toButton_ex is queue 2 of Button_exEvents
type toControllerSys is queue 2 of ControllerSysEvents
type toWinch is queue 2 of WinchEvents
type toCabin is queue 2 of CabinEvents
type toDoor is queue 2 of DoorEvents
type toSensor is queue 2 of SensorEvents
type toSensor is queue 2 of SensorEvents
type toSensor is queue 2 of SensorEvents
type toSensor is queue 2 of SensorEvents
type toSensor is queue 2 of SensorEvents
	
/*============================= process ============================================================*/
	Process Button_ex [
					&requestFloor : int,
]

 (
					&requestFloor : int,
		)

	is
		states 
			Off,
			On
	init
		toButton_ex := ;
		to Off

	from Off
		output ! requestFloor;

		to On
	from On
		if (empty toButton_ex) then loop end;
received := first toButton_ex;
toButton_ex := dequeue(toButton_ex);
if (received = arrive) then
    to Off
end
		to Off
		wait[4,5];
		to Off

	Process ControllerSys [
					&requestedTargetFloor : int,
					&requestedFloor : int,
]

 (
					&requestedTargetFloor : int,
					&requestedFloor : int,
		)

	is
		states 
			Wait,
			cabinMoved,
			cabinArrived,
			doorOpened,
			doorClosed,
			receiveRequestFromButtonEx,
			cabinBraked,
			recievedRequestFromCabin,
			waitDoorClosed
		var 
			toControllerSys,
			exBtnFloor,
			currentFloor,
			isBusy,
			upordown,
			targetFloor,
			destFloor
			loadedPassager
	init
		toControllerSys := ;
		exBtnFloor := -1;
		currentFloor := 0;
		isBusy := false;
		upordown := 0;
		targetFloor := -1;
		destFloor := -1;
		loadedPassager := false;
		to Wait

	from Wait
		input ? exBtnFloor;     
destFloor := exBtnFloor;
if (currentFloor < exBtnFloor) then
            toWinch = enqueue(toWinch, goUp);
	upordown := 1;  
            case floor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor, toMeasure(currentFloor, floor));   
            end;
else
	if (currentFloor == exBtnFloor)  then      
                        toControllerSys = enqueue(toControllerSys, gotoOpenDoorDirectly)
	else
                        toWinch = enqueue(toWinch, goDown)
	            upordown := -1;  
		case floor of 
	                0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	             |  1 ->  toSensor1 = enqueue(toSensor, toMeasure(currentFloor, floor));     	  
	             |  2 ->  toSensor2 = enqueue(toSensor, toMeasure(currentFloor, floor));  	 
	             |  3 ->  toSensor3 = enqueue(toSensor, toMeasure(currentFloor, floor));   
	             |  4 ->  toSensor4 = enqueue(toSensor, toMeasure(currentFloor, floor));   
                        end;
	end;
end;
		to receiveRequestFromButtonEx
	from cabinMoved
		toWinch = enqueue(toWinch, stopFromController);

		to cabinArrived
		currentFloor := currentFloor + upordown;   
sendToMeasureSensor(destFloor);
case destFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor, toMeasure(currentFloor, floor));   
 end;

		to cabinMoved
	from cabinArrived
		toWinch = enqueue(toWinch, stop);

		to cabinBraked
	from doorOpened
		toDoor := enqueue(toDoor, CloseDoor);
targetFloor := params.requestedTargetFloor;    
destFloor := targetFloor;
		to doorClosed
		toDoor := enqueue(toDoor, CloseDoor);
		to waitDoorClosed
	from doorClosed
		if (currentFloor < targetFloor) then
            toWinch := enqueue(toWinch, goUp); 
	upordown := 1; 
	sendToMeasureSensor(targetFloor);
else
	if (currentFloor = targetFloor) then       
                        toControllerSys := enqueue(toControllerSys, gotoOpenDoorDirectly); 
	else
		toWinch := enqueue(toWinch, goDown); 
		upordown := upordown-1;  
		case targetFloor of 
	                0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	             |  1 ->  toSensor1 = enqueue(toSensor, toMeasure(currentFloor, floor));     	  
	             |  2 ->  toSensor2 = enqueue(toSensor, toMeasure(currentFloor, floor));  	 
	             |  3 ->  toSensor3 = enqueue(toSensor, toMeasure(currentFloor, floor));   
	             |  4 ->  toSensor4 = enqueue(toSensor, toMeasure(currentFloor, floor));   
                         end;
	end;
end;
		to recievedRequestFromCabin
		loadedPassager := false;
		to Wait
	from receiveRequestFromButtonEx
		currentFloor := currentFloor+ upordown;   
case floor of 
	      0 ->  toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor, toMeasure(currentFloor, floor));   
end;

		to cabinMoved
		toControllerSys := enqueue(toControllerSys, readyToOpenDoor);

		to cabinBraked
	from cabinBraked
		toDoor := enqueue(toDoor, OpenDoor);
toButton_ex := enqueue(toDoor, OpenDoor);

		to doorOpened
	from recievedRequestFromCabin
		currentFloor := currentFloor+upordown;   
loadedPassager := true;        
 case destFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor, toMeasure(currentFloor, floor));   
end;

		to cabinMoved
		toControllerSys := enqueue(toCOntrollerSys, readyToOpenDoor);
		to cabinBraked
	from waitDoorClosed
		toControllerSys := enqueue(toControllerSys, doneTask)
		to doorClosed

	Process Winch [
]

 (
		)

	is
		states 
			Not_Going,
			Going_Up,
			Going_Down,
			receiveCabinBrakedFromControllerSys
		var 
			toWinch,
			motor,
			frein
			selector
	init
		toWinch := ;
		motor := ;
		frein := ;
		selector := ;
		to Not_Going

	from Not_Going
		toCabin := enqueue(toCabin moveCabinUp);
		to Going_Up
		toCabin := enqueue (toCabin, moveCabinDown);
		to Going_Down
	from Going_Up
		toCabin := enqueue(toCabin, braked);
		to receiveCabinBrakedFromControllerSys
	from Going_Down
		toCabin := enqueue(toCabin,braked);
		to receiveCabinBrakedFromControllerSys
	from receiveCabinBrakedFromControllerSys
		toControllerSys := enqueue(toControllerSys,readyToOpenDoor);
		to Not_Going

	Process Cabin [
					&targetFloor : int,
]

 (
					&targetFloor : int,
		)

	is
		states 
			Stop,
			Down,
			sentInfo,
			Up
		var 
			toCabin
			currentFloor
	init
		toCabin := ;
		currentFloor := 0;
		to Stop

	from Stop
		toControllerSys := enqueue(toControllerSys, receiveFloorAndCloseDoor(params.targetFloor));
		to sentInfo
		toControllerSys := enqueue(toControllerSys, receiveCabinMoved);

		to Down
		toControllerSys := enqueue(toControllerSys, receiveCabinMoved );
		to Up
	from Down
		toControllerSys := enqueue (toControllerSys, braked);

		to Stop
	from sentInfo
		toControllerSys := enqueue (toControllerSys, receiveCabinMoved);
		to Down
		toControllerSys := enqueue(toControllerSys,  receiveCabinMoved );
		to Up
	from Up
		toControllerSys := enqueue(toControllerSys, braked);
		to Stop

	Process Door [
]

 (
		)

	is
		states 
			Open,
			Closed,
			Sleep
	init
		toDoor := ;
		to Sleep

	from Open
		if (empty toDoor) then loop end;
received := first toDoor;
toDoor := dequeue(toDoor);
if (received = CloseDoor) then to Closed end;
		to Closed
	from Closed
		toControllerSys := enqueue (toController, readyToGo);
		to Sleep
	from Sleep
		if (empty toDoor) then loop end;
received := first toDoor;
toDoor := dequeue(toDoor);
if (received = OpenDoor) then to Open end;
		to Open

	Process Sensor [
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
]

 (
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
		)

	is
		states 
			Idle,
			Detecting,
			Detected
		var 
			toSensor,
			floor
			cabinFloor
	init
		toSensor := ;
		floor := -1;
		cabinFloor := -1;
		to Idle

	from Idle
		floor := params.sensorFloor;
cabinFloor := params.currentFloor;
		to Detecting
	from Detecting
		toControllerSys := enqueue (toControllerSys, detected);
		to Detected
		cabinFloor=params.currentFloor; 
if (floor = cabinFloor)  then
            case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor,cabinArrived);   
	   |  1 ->  toSensor1 = enqueue(toSensor1, cabinArrived);     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, cabinArrived);  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, cabinArrived);   
	   |  4 ->  toSensor4 = enqueue(toSensor4, cabinArrived);   
            end;
else
	wait[1,2];
	case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor1, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor4, toMeasure(currentFloor, floor));   
            end;
end;
		to Detecting
	from Detected
		wait[1,2]
		to Idle

	Process Sensor [
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
]

 (
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
		)

	is
		states 
			Idle,
			Detecting,
			Detected
		var 
			toSensor,
			floor
			cabinFloor
	init
		toSensor := ;
		floor := -1;
		cabinFloor := -1;
		to Idle

	from Idle
		floor := params.sensorFloor;
cabinFloor := params.currentFloor;
		to Detecting
	from Detecting
		toControllerSys := enqueue (toControllerSys, detected);
		to Detected
		cabinFloor=params.currentFloor; 
if (floor = cabinFloor)  then
            case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor,cabinArrived);   
	   |  1 ->  toSensor1 = enqueue(toSensor1, cabinArrived);     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, cabinArrived);  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, cabinArrived);   
	   |  4 ->  toSensor4 = enqueue(toSensor4, cabinArrived);   
            end;
else
	wait[1,2];
	case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor1, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor4, toMeasure(currentFloor, floor));   
            end;
end;
		to Detecting
	from Detected
		wait[1,2]
		to Idle

	Process Sensor [
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
]

 (
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
		)

	is
		states 
			Idle,
			Detecting,
			Detected
		var 
			toSensor,
			floor
			cabinFloor
	init
		toSensor := ;
		floor := -1;
		cabinFloor := -1;
		to Idle

	from Idle
		floor := params.sensorFloor;
cabinFloor := params.currentFloor;
		to Detecting
	from Detecting
		toControllerSys := enqueue (toControllerSys, detected);
		to Detected
		cabinFloor=params.currentFloor; 
if (floor = cabinFloor)  then
            case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor,cabinArrived);   
	   |  1 ->  toSensor1 = enqueue(toSensor1, cabinArrived);     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, cabinArrived);  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, cabinArrived);   
	   |  4 ->  toSensor4 = enqueue(toSensor4, cabinArrived);   
            end;
else
	wait[1,2];
	case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor1, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor4, toMeasure(currentFloor, floor));   
            end;
end;
		to Detecting
	from Detected
		wait[1,2]
		to Idle

	Process Sensor [
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
]

 (
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
		)

	is
		states 
			Idle,
			Detecting,
			Detected
		var 
			toSensor,
			floor
			cabinFloor
	init
		toSensor := ;
		floor := -1;
		cabinFloor := -1;
		to Idle

	from Idle
		floor := params.sensorFloor;
cabinFloor := params.currentFloor;
		to Detecting
	from Detecting
		toControllerSys := enqueue (toControllerSys, detected);
		to Detected
		cabinFloor=params.currentFloor; 
if (floor = cabinFloor)  then
            case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor,cabinArrived);   
	   |  1 ->  toSensor1 = enqueue(toSensor1, cabinArrived);     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, cabinArrived);  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, cabinArrived);   
	   |  4 ->  toSensor4 = enqueue(toSensor4, cabinArrived);   
            end;
else
	wait[1,2];
	case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor1, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor4, toMeasure(currentFloor, floor));   
            end;
end;
		to Detecting
	from Detected
		wait[1,2]
		to Idle

	Process Sensor [
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
]

 (
					&currentFloor : int,
					&sensorFloor : int,
					&currentFloor : int,
					&sensorFloor : int,
		)

	is
		states 
			Idle,
			Detecting,
			Detected
		var 
			toSensor,
			floor
			cabinFloor
	init
		toSensor := ;
		floor := -1;
		cabinFloor := -1;
		to Idle

	from Idle
		floor := params.sensorFloor;
cabinFloor := params.currentFloor;
		to Detecting
	from Detecting
		toControllerSys := enqueue (toControllerSys, detected);
		to Detected
		cabinFloor=params.currentFloor; 
if (floor = cabinFloor)  then
            case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor,cabinArrived);   
	   |  1 ->  toSensor1 = enqueue(toSensor1, cabinArrived);     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, cabinArrived);  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, cabinArrived);   
	   |  4 ->  toSensor4 = enqueue(toSensor4, cabinArrived);   
            end;
else
	wait[1,2];
	case sensorFloor of 
	      0 -> toSensor = enqueue(toSensor, toMeasure(currentFloor, floor));   
	   |  1 ->  toSensor1 = enqueue(toSensor1, toMeasure(currentFloor, floor));     	  
	   |  2 ->  toSensor2 = enqueue(toSensor2, toMeasure(currentFloor, floor));  	 
	   |  3 ->  toSensor3 = enqueue(toSensor3, toMeasure(currentFloor, floor));   
	   |  4 ->  toSensor4 = enqueue(toSensor4, toMeasure(currentFloor, floor));   
            end;
end;
		to Detecting
	from Detected
		wait[1,2]
		to Idle

/*============================= Component ===========================================================*/
	Component InstanceClsDiag is 
	par
	
	
			Button_ex,
			ControllerSys,
			Winch,
			Cabin,
			Door,
			Sensor,
			Sensor,
			Sensor,
			Sensor,
			Sensor
	

