
type Double_Floor is record
	first : int,
	second : int
end

	/*process*/
	Process Button_ex 
	[
	
	  receiveFromButton_Ex : out int
    ]

 
	is
	states 
			Off_Button_ex,
			On_Button_ex
	init
		to Off_Button_ex

	from Off_Button_ex
		receiveFromButton_Ex ! 3;
        to On_Button_ex
	
	from On_Button_ex
		to Off_Button_ex
	

	Process ControllerSys 
	[
	  detected : in none,	
	  readyToOpenDoor : in none,	
	  receiveFloorAndCloseDoor : in,
	  readyToGo : in none,	
	  receiveFromButton_Ex : in,
	  receiveCabinMoved : in none,	
	  braked : in none,	
	  gotoOpenDoorDirectly : in none,	
	  continueToMove : in none,	
	  doneTask : in none,	
	  goUp : out  none,
      goDown : out none,
      p_con_sen_toMeasure : out Double_Floor 
      stopFromController : out none,   
      stop : out none,
      OpenDoor : out none,
      CloseDoor : out none
    ]

 
	is
	states 
			Wait_ControllerSys,
			cabinMoved_ControllerSys,
			cabinArrived_ControllerSys,
			doorOpened_ControllerSys,
			doorClosed_ControllerSys,
			receiveRequestFromButtonEx_ControllerSys,
			cabinBraked_ControllerSys,
			recievedRequestFromCabin_ControllerSys,
			waitDoorClosed_ControllerSys
		var 
			exBtnFloor,
			currentFloor,
			isBusy,
			upordown,
			targetFloor,
			destFloor,
			loadedPassager
	init
		exBtnFloor := -1;
		currentFloor := 0;
		isBusy := false;
		upordown := 0;
		targetFloor := -1;
		destFloor := -1;
		loadedPassager := false;
		to Wait_ControllerSys

	from Wait_ControllerSys
		receiveFromButton_Ex ?  exBtnFloor;
         destFloor := exBtnFloor;
         if (currentFloor < exBtnFloor) then
              goUp;   
              upordown :=1 ;  
              toMeasure ! currentFloor, exBtnFloor
              to ReceiveRequestFromButtonEx_ControllerSys
         elsif (currentFloor > exBtnFloor) then 	
               goDown; 
               upordown := -1;  
               toMeasure !  currentFloor,  exBtnFloor
               to ReceiveRequestFromButtonEx
         else
                to ReceiveRequestFromButtonEx
         end


	
	from cabinMoved_ControllerSys
		select
              detected;
              stopFromController;
              to cabinArrived_ControllerSys
	
		[]
              continueToMove;
              currentFloor = currentFloor +upordown; 
              toMeasureSensor ! currentFloor, destfloor;
              to cabinMoved_ControllerSys
         end;



	
	from cabinArrived_ControllerSys
		braked;
          stop;
          to cabinBraked
	
	from doorOpened_ControllerSys
		targetFloor := 1;
          destFloor := targetFloor;
          closeDoor;
          to doorClosed_ControllerSys
	
		if (loadedPassager) then
          CloseDoor;
          to waitDoorClosed
        end
	
	from doorClosed_ControllerSys
		readyToGo;
          if (currentFloor < targetFloor) then
              goUp;   
              upordown := 1; 
              toMeasure ! currentFloor, exBtnFloor;
              to recievedRequestFromCabin_ControllerSys
          else
                if (currentFloor = targetFloor) then
                    openDoor;
                    to doorOpened_ControllerSys
                else
                     goDown; 
                     upordown := -1;  
                     toMeasure ! currentFloor, exBtnFloor
                     to recievedRequestFromCabin_ControllerSys
                end
          end 

	
	
	from receiveRequestFromButtonEx_ControllerSys
		receiveCabinMoved;
          currentFloor := currentFloor + upordown;
          case (exBtnFloor) of 
               0 ->  sendToMeasureSensor ! currentFloor, exBtnFloor
            | 1 ->  sendToMeasureSensor_1 !  currentFloor, exBtnFloor
            | 2 ->  sendToMeasureSensor_2 !  currentFloor, exBtnFloor
            | 3 ->  sendToMeasureSensor_3 !  currentFloor, exBtnFloor
            | 4 ->  sendToMeasureSensor_4 !  currentFloor, exBtnFloor
           end;
           to cabinMoved_ControllerSys

	
		if (currentFloor = exBtnFloor) then   
                p_con_door_OpenDoor;
                to doorOpened
          end;

	
	from cabinBraked_ControllerSys
		readyToOpenDoor;
          OpenDoor;
          to doorOpened_ControllerSys

	
	from recievedRequestFromCabin_ControllerSys
		receiveCabinMoved;
          currentFloor := currentFloor + upordown;
          loadedPassager := true;
          case (destFloor) of 
               0 ->  sendToMeasureSensor ! currentFloor, destFloor
            | 1 ->  sendToMeasureSensor_1 ! currentFloor,destFloor
            | 2 ->  sendToMeasureSensor_2 ! currentFloor, destFloor
            | 3 ->  sendToMeasureSensor_3 ! currentFloor,destFloor
            | 4 ->  sendToMeasureSensor_4 ! currentFloor, destFloor
         end;
         to cabinMoved_ControllerSys

	
	
	from waitDoorClosed_ControllerSys
		readyToGo;
          loadedPassager := false;
          to Wait_ControllerSys

	

	Process Winch 
	[
	  goUp : in none,	
	  stop : in none,	
	  goDown : in none,	
	  stopFromController : in none,	
	  moveCabinUp : out none,
      moveCabinDown : out none
      braked : out none,
      readyToOpenDoor : out none
    ]

 
	is
	states 
			Not_Going_Winch,
			Going_Up_Winch,
			Going_Down_Winch,
			receiveCabinBrakedFromControllerSys_Winch
		var 
			motor,
			frein,
			selector
	init
		motor := 0;
		frein := 0;
		selector := 0;
		to Not_Going_Winch

	from Not_Going_Winch
		select
          goUp;
          moveCabinUp;
          to Going_Up_Winch
	
		[]
          goDown;
          moveCabinDown;
          to Goinf_Down_Winch
        end
	
	from Going_Up_Winch
		stopFromController;
        braked;
        to receiveCabinBrakedFromControllerSys
	
	from Going_Down_Winch
		stopFromController;
        braked;
        to receiveCabinBrakedFromControllerSys
	
	from receiveCabinBrakedFromControllerSys_Winch
		stop;
        readyToOpenDoor;
        to Not_Going_Winch
	

	Process Cabin 
	[
	  braked : in none,	
	  sendFloorAndCloseDoor : in,
	  moveCabinDown : in none,	
	  moveCabinUp : in none,	
	  receiveFloorAndCloseDoor : out int,
      braked : out none,
      receiveCabinMoved : out none
    ]

 
	is
	states 
			Stop_Cabin,
			Down_Cabin,
			sentInfo_Cabin,
			Up_Cabin
		var 
			currentFloor
	init
		currentFloor := 0;
		to Stop_Cabin

	from Stop_Cabin
		select
          sendFloorAndCloseDoor  ?  targetFloor;
          receiveFloorAndCloseDoor !  targetFloor;
          to sentInfo_Cabin
	
		[] 
          moveCabinDown;
          receiveCabinMoved;
          to Down_Cabin
	
		[]
          moveCabinUp;
          receiveCabinMoved;
          to Up_Cabin
        end


	
	from Down_Cabin
		braked;
        braked;
         to Stop_Cabin
	
	from sentInfo_Cabin
		select
          moveCabinDown ;
          receiveCabinMoved;
          to Down_Cabin
	
		[]
          moveCabinUp;
          receiveCabinMoved;
          to Up_Cabin
        end
	
	from Up_Cabin
		braked;
         braked;
         to Stop_Cabin

	

	Process Door 
	[
	  OpenDoor : in none,	
	  CloseDoor : in none,	
	  readyToGo : out none
    ]

 
	is
	states 
			Open_Door,
			Closed_Door,
			Sleep_Door
	init
		to Sleep_Door

	from Open_Door
		CloseDoor;
        to Closed_Door
	
	from Closed_Door
		readyToGo;
        to Sleep_Door
	
	from Sleep_Door
		OpenDoor;
        to Open_Door

	

	Process Sensor 
	[
	  toMeasure : in,
	  cabinArrived : in none,	
	  p_sen_con_continueToMove : out none,  
       p_sen_con_1_continueToMove : out none,   
       p_sen_con_2_continueToMove : out none,
       p_sen_con_3_continueToMove : out none,
       p_sen_con_4_continueToMove : out none       

    ]

 
	is
	states 
			Idle_Sensor,
			Detecting_Sensor,
			Detected_Sensor
		var 
			floor,
			cabinFloor
	init
		floor := -1;
		cabinFloor := -1;
		to Idle_Sensor

	from Idle_Sensor
		toMeasure ?  floor, cabinFloor;
         to Detecting_Sensor

	
	from Detecting_Sensor
		

	
		toMeasure ? cabinFloor;
          if (floor = cabinFloor) then 
            case (floor) of 
          0 -> p_sen_con_detected; to Detected_Sensor 
       | 1 -> P_sen_con_1_detected; to Detected_Sensor
       | 2 -> p_sen_con_2_detected; to Detected_Sensor   
       | 3 -> p_sen_con_3_detected; to Detected_Sensor 
       | 4 -> p_sen_con_4_detected; to Detected_Sensor
          end
          else
            case (floor) of 
               0 -> p_sen_con_continueToMove 
            | 1 -> P_sen_con_1_continueToMove
            | 2 -> p_sen_con_2_continueToMove
            | 3 -> p_sen_con_3_continueToMove 
            | 4 -> p_sen_con_4_continueToMove
           end;
           to Detected_Sensor
         end

	
	from Detected_Sensor
		to Idle_Sensor
	

	/*Component*/
	Component InstanceClsDiag is 
	var
		sensor0 : int := 0,
		sensor1 : int := 1,
		sensor2 : int := 2,
		sensor3 : int := 3,
		sensor4 : int := 4
		
	port 
				Pressed : ,
				detected : none,	
				readyToOpenDoor : none,	
				receiveFloorAndCloseDoor : ,
				readyToGo : none,	
				receiveFromButton_Ex : ,
				receiveCabinMoved : none,	
				braked : none,	
				gotoOpenDoorDirectly : none,	
				continueToMove : none,	
				doneTask : none,	
				goUp : none,	
				stop : none,	
				goDown : none,	
				stopFromController : none,	
				braked : none,	
				sendFloorAndCloseDoor : ,
				moveCabinDown : none,	
				moveCabinUp : none,	
				OpenDoor : none,	
				CloseDoor : none,	
				toMeasure : ,
				cabinArrived : none,	
				toMeasure : ,
				cabinArrived : none,	
				toMeasure : ,
				cabinArrived : none,	
				toMeasure : ,
				cabinArrived : none,	
				toMeasure : ,
				cabinArrived : none,	
	par
	
			Button_ex
			|| ControllerSys
			|| Winch
			|| Cabin
			|| Door
			|| Sensor
			|| Sensor
			|| Sensor
			|| Sensor
			|| Sensor
		
	

